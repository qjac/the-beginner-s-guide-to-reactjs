<div id="root"></div>
<script src="https://unpkg.com/react@16.3.0/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@16.3.0/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/prop-types@15.6.0/prop-types.js"></script>
<script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>
<script type="text/babel">
// 01
// Create HTML elements with React's createElement API
	// create element with vanilla js
	// const rootElement = document.getElementById('root')
	// const element = document.createElement('div')
	// element.textContent = 'Hello world'
	// element.className = 'container'
	// rootElement.appendChild(element)

	// create element the react way
	// need to import react and react DOM
	// const rootElement = document.getElementById('root')
	// const element =React.createElement('div', {className: 'container'}, 'Hello world')
	// console.log(element)
	// ReactDOM.render(element, rootElement)

	
// 02
// Replace React createElement Function Call with JSX
	// create element the jsx way
	// jsx needs to be transpiled, usually would be transpiled as part of build process
	// this time we'll be importing babel in a script tag
	// const rootElement = document.getElementById('root')
	// const element = <div className="container">Hello world</div>
	// ReactDOM.render(element, rootElement)

	// jsx passing props
	// const rootElement = document.getElementById('root')
	// const props = {
	// 	className : 'container',
	// 	children:'Hello world'
	// }
	// const element = <div {...props} />
	// ReactDOM.render(element, rootElement)

	
// 03
// Create a Simple Reusable React Component
	// 	using function call
	// const rootElement = document.getElementById('root')

	// const message = (props) => <div>{props.msg}</div>

	// const element = (
	// 	<div className="container">
	// 	{message({msg: 'Hello World'})}
	// 	{message({msg: 'Goodbye World'})}
	// </div>
	// );

	// ReactDOM.render(element, rootElement);

	// create simple reusable component with easier to read jsx
	// const rootElement = document.getElementById('root')

	// const Message = props => <div>{props.msg}</div>
	// const element = (
	// 	<div className="container">
	// 		<Message msg='Hello World' />
	// 		<Message msg='Goodbye World' />
	// 	</div>
	// );
	// ReactDOM.render(element, rootElement);


	// create simple reusable component with easier to read jsx using children instead of props
	// const rootElement = document.getElementById('root')

	// const Message = props => <div>{props.children}</div>
	// const element = (
	// 	<div className="container">
	// 	<Message>
	// 		Hello World
	// 		<Message>Goodbye World</Message>
	// 	</Message>
	// 	</div>
	// );
	// ReactDOM.render(element, rootElement);

	
// 04
// Validate Custom React Component Props with PropTypes

	// no vlaidation
	// const rootElement = document.getElementById('root')
	// // this is a function component
	// function SayHello(props) {
	// 	return (
	// 		<div>
	// 		Hello {props.firstName} {props.lastName}!
	// 		</div>
	// 	)};

	// // it's expecting the prop to be a string not a boolean. results in incorrect rendering
	// ReactDOM.render(<SayHello firstName={true} />, rootElement)

	// // with validation
	// const rootElement = document.getElementById('root')
	// function SayHello(props) {
	// 	return (
	// 		<div>
	// 		Hello {props.firstName} {props.lastName}!
	// 		</div>
	// 	)};

	// 	// validate proptypes
	// SayHello.propTypes = {
	// 	firstName(props, propName, componentName) {
	// 		if(typeof props[propName] !== 'string') {
	// 			return new Error(
	// 				`Pass a string for ${propName} in ${componentName}. You passed a ${typeof props[propName]}`
	// 				)
	// 		}
	// 	}
	// }

	// // it's expecting the prop to be a string not a boolean. results in incorrect rendering
	// ReactDOM.render(<SayHello firstName={true} />, rootElement)

	// validate multiple props for correct proptype. pull it out into a function.
	// const rootElement = document.getElementById('root')

	// function SayHello(props) {
	// 	return (
	// 		<div>
	// 		Hello {props.firstName} {props.lastName}!
	// 		</div>
	// 	)};

	// // validate all string proptypes using function
	// const PropTypes = {
	// 	string(props, propName, componentName) {
	// 		if(typeof props[propName] !== 'string') {
	// 			return new Error(
	// 				`Pass a string for ${propName} in ${componentName}. You passed a ${typeof props[propName]}!`
	// 			)
	// 		}
	// 	},
	// }

	// SayHello.propTypes = {
	// 	firstName: PropTypes.string,
	// 	lastName: PropTypes.string,
	// }

	// // it's expecting the prop to be a string not a boolean. results in incorrect rendering
	// ReactDOM.render(<SayHello firstName={true} />, rootElement)

	// using the prop-types library
	// https://reactjs.org/docs/typechecking-with-proptypes.html
	// script to library pulled in at top of page. 

	// const rootElement = document.getElementById('root')

	// function SayHello(props) {
	// 	return (
	// 		<div>
	// 		Hello {props.firstName} {props.lastName}!
	// 		</div>
	// 	)};

	// // validation comes from imported prop-types package. custom function no longer needed
	// SayHello.propTypes = {
	// 	firstName: PropTypes.string.isRequired,
	// 	lastName: PropTypes.string.isRequired,
	// }

	// // it's expecting the prop to be a string not a boolean. 
	// // results in incorrect rendering. should throw an error.
	// ReactDOM.render(<SayHello firstName={true} />, rootElement)

	// now with class component instead of function component. same great validating.
	// const rootElement = document.getElementById('root')

	// class SayHello extends React.Component {
	// 	 // works the same as having protype validated seperately, but more common to have it as static method in class component
	// 	static propTypes = {
	// 		firstName: PropTypes.string.isRequired,
	// 		lastName: PropTypes.string.isRequired,
	// 	}
	// 	render() {
	// 		const {firstName, lastName} = this.props
		
	// 	return (
	// 		<div>
	// 		Hello {firstName} {lastName}!
	// 		</div>
	// 	)}
	// }

	// // it's expecting the prop to be a string not a boolean. 
	// // results in incorrect rendering. should throw an error.
	// ReactDOM.render(<SayHello firstName={true} />, rootElement)

	// propType checking only works with dev version of react. it's turned off for production to speed up app.
	// can add babel-plugin-transform-react-remove-prop-types to build step to automatically remove proptype checking code from codebase in production to speed it up further.


// 05
// Conditionally Render a React Component
	// renders even if message content is null (renders empty div)
	// function Message({message}) {
	// 	return <div>{message}</div>
	// }
	// ReactDOM.render(<Message message={null} />,
	// document.getElementById('root'))

	// render conditionally
	// function Message({message}) {
	// 	if (!message) {return <div>No message</div>}
	// 	return <div>{message}</div>
	// }
	// ReactDOM.render(<Message message={null} />,
	// document.getElementById('root'))

	// with ternary and wrapped in a div
	// function Message({message}) {
	// 	return (
	// 		<div>
	// 		{message ? (<div>{message}</div>) : (<div>No message</div>)}
	// 		</div>
	// 	)
	// }
	
	// ReactDOM.render(<Message message="{null}" />,
	// document.getElementById('root'))


// 06
// Rerender a React Application
	// demo to show selective rerendering (fun to watch repaint in dev tools)
	// const rootElement = document.getElementById('root')

	// function tick() {
	// 	const time = new Date().toLocaleTimeString()
	// 	const element = <div>It is {time}.</div>
	// 	ReactDOM.render(element, rootElement)
	// }
	// setInterval(tick, 1000)


// 07
// Style React Components with className and In-line Styles
	// copied over the styles 
	</script>
	<style>
		.box {
		  border: 1px solid #333;
		}

		.box--large {
		  width: 180px;
		  height: 180px;
		}

		.box--medium {
		  width: 120px;
		  height: 120px;
		}

		.box--small {
		  width: 60px;
		  height: 60px;
		}
	</style>

<script type="text/babel">
	// // styles inline and adding classes directly in jsx
	// const rootElement = document.getElementById('root')
	// const element = (
	// 	<div>

	// 		<div 
	// 			// add new classes like so
	// 			className="box box--small"
	// 			// add inline style in jsx as an object. for most tyle properties, numbers w/o unit will translate as px.
	// 			style={{paddingLeft: '20px'}}>
	// 			box
	// 		</div>
	// 	</div>
	// 	)
	// ReactDOM.render(element, rootElement)

	// // adding styles via props. 
	// const rootElement = document.getElementById('root')
	// const props = {
	// 	className: "box box--small",
	// 	style: {paddingLeft: '20px'},
	// }
	// const element = (
	// 	<div>
	// 		// spreading props into div is equivalent to above.
	// 		<div {...props}>box</div>
	// 	</div>
	// 	)
	// ReactDOM.render(element, rootElement)

	// // adding styles via props using object shorthand 
	// const rootElement = document.getElementById('root')
	// // note: can't use class as a variable name in js. throws an error and doesn't allow for destructuring
	// const className = "box box--small";
	// const props = {
	// 	className, //object shorthand matches this variable name with it's object property
	// 	style: {paddingLeft: '20px'},
	// }
	// const element = (
	// 	<div>
			
	// 		<div {...props}>box</div>
	// 	</div>
	// 	)
	// ReactDOM.render(element, rootElement)

	// let's do it as a function component. equivalent to above
	// const rootElement = document.getElementById('root')
	// function Box(props) {
	// 	return (
	// 		<div
	// 			className="box box--small"
	// 			style={{paddingLeft: 20}}
	// 			{...props}
	// 			>
	// 			box
	// 		</div>
	// 	)
	// }
	// ReactDOM.render(<Box />, rootElement)

	// //  adding props to function component
	// const rootElement = document.getElementById('root')
	// function Box(props) {
	// 	return (
	// 		<div
	// 			className="box box--small"
	// 			style={{paddingLeft: 20}}
	// 			{...props}
	// 		/>
	// 	)
	// }

	// const element = ( 
	// 	<div>
	// 		<Box style={{backgroundColor: 'aliceBlue'}}>small box</Box>
	// 	</div>
	// )
	// ReactDOM.render(element, rootElement) //object spread does a shallow merge of props, so adding style prop overwrites the style prop in the function component. 

	// //  adding props to function component w/o overwriting
	// // do some destructuring to seperate out the style prop
	// const rootElement = document.getElementById('root')
	// function Box({style, ...rest}) {
	// 	return (
	// 		<div
	// 			className="box box--small"
	// 			style={{paddingLeft: 20, ...style}} //merges new style props with this one
	// 			{...rest}
	// 		/>
	// 	)
	// }
	// const element = ( 
	// 	<div>
	// 		<Box style={{backgroundColor: 'aliceBlue'}}>small box</Box>
	// 	</div>
	// )
	// ReactDOM.render(element, rootElement) //adding style prop overwrites the style prop in the function component

	// // now let's do that for className
	// const rootElement = document.getElementById('root')
	// // add a default value to the className prop to avoid an undefined making its way into the class list of the component
	// function Box({style, className='', ...rest}) {
	// 	return (
	// 		<div
	// 			className={`box ${className}`} // use a template literal instead of a string so you can pop in a variable for interpolation
	// 			style={{paddingLeft: 40, ...style}} //merges new style props with this one
	// 			{...rest}
	// 		/>
	// 	)
	// }
	// const element = ( 
	// 	<div>
	// 		<Box className="box--small" style={{backgroundColor: 'aliceBlue'}}>small box</Box>
	// 		<Box className="box--medium" style={{backgroundColor: 'mistyRose'}}>medium box</Box>
	// 		<Box className="box--large" style={{backgroundColor: 'honeyDew'}}>large box</Box>
	// 	</div>
	// )
	// ReactDOM.render(element, rootElement) //adding style prop overwrites the style prop in the function component

	// use size prop to automatically add correct class to box of that size for maximum composability
	const rootElement = document.getElementById('root')
	// add a default value to the className prop to avoid an undefined making its way into the class list of the component
	function Box({style, size, className='', ...rest}) {
		const sizeClassName = size ? `box--${size}` : ''
		return (
			<div

				className={`box ${sizeClassName} ${className}`} // use a template literal instead of a string so you can pop in a variable for interpolation
				style={{paddingLeft: 40, ...style}} //merges new style props with this one
				{...rest}
			/>
		)
	}
	const element = ( 
		<div>
			<Box size="small" style={{backgroundColor: 'aliceBlue'}}>small box</Box>
			<Box size="medium" style={{backgroundColor: 'mistyRose'}}>medium box</Box>
			<Box size="large" style={{backgroundColor: 'honeyDew'}}>large box</Box>
		</div>
	)
	ReactDOM.render(element, rootElement) //adding style prop overwrites the style prop in the function component




</script>